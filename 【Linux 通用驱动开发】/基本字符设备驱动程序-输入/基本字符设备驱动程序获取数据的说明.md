# 基本字符设备驱动程序获取数据的说明

引 100ask，侵删。

------

## 概念

应用程序 APP 的读取驱动程序的四种基本方式：阻塞、非阻塞、poll 和 异步通知（注册SIGIO信号回调函数。信号之于应用程序，相当于中断之于驱动程序）。这部分详见 `【Linux 应用开发】\1-文件io读写的基本四种机制` 里的介绍和例子。

相应的 驱动程序 也类似的提供这四种基本的 读取和上报应用程序的 编写模式。

因此驱动程序支持这四种的哪一种方式或多种，应用程序才能使用哪一种或多种方式进行数据获取，应用程序的写法是与驱动程序所提供的功能紧密相关的。

> **驱动程序提供能力，不提供策略**
>
> 我们的驱动程序可以实现下述4种提供按键的方法，但是驱动程序不应该限制APP使用哪种方法。
>
> 这就是驱动设计的一个原理：提供能力，不提供策略。**就是说，你想用哪种方法都行，驱动程序都可以提供；但是驱动程序不能限制你使用哪种方法**。

> **查询**（相当于应用程序的 **非阻塞方式**获取）：
>
> 驱动程序中构造、注册一个file_operations结构体，里面提供有对应的open,read函数。APP调用open时，导致驱动中对应的open函数被调用，在里面配置GPIO为输入引脚。APP调用read时，导致驱动中对应的read函数被调用，它读取寄存器，把引脚状态直接返回给APP。
>
> **休眠-中断**（相当于应用程序的 **阻塞方式**获取）：
>
> - 驱动程序中构造、注册一个file_operations结构体，里面提供有对应的open,read函数。
> - APP调用open时，导致驱动中对应的open函数被调用，在里面配置GPIO为输入引脚；并且注册GPIO的中断处理函数。
> - APP调用read时，导致驱动中对应的read函数被调用，如果有按键数据则直接返回给APP；否则APP在内核态休眠。
> - 当用户按下按键时，GPIO中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，并唤醒休眠中的APP。
> - APP被唤醒后继续在内核态运行，即继续执行驱动代码，把按键数据返回给APP(的用户空间)。
>
> **poll 方式**（相当于应用程序的 poll方式获取）：
>
> - 上面的休眠-唤醒方式有个缺点：如果用户一直没操作按键，那么APP就会永远休眠。
> - 我们可以给APP加个等待超时时间，这就是poll方式。
> - 驱动程序中构造、注册一个file_operations结构体，里面提供有对应的open,read,poll函数。
> - APP调用open时，导致驱动中对应的open函数被调用，在里面配置GPIO为输入引脚；并且注册GPIO的中断处理函数。
> - APP调用poll或select函数，意图是“查询”是否有数据，这2个函数都可以指定一个超时时间，即在这段时间内没有数据的话就返回错误。这会导致驱动中对应的poll函数被调用，如果有按键数据则直接返回给APP；否则APP在内核态休眠一段时间。
> - 当用户按下按键时，GPIO中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，并唤醒休眠中的APP。
> - 如果用户没按下按键，但是超时时间到了，内核也会唤醒APP。
> - 所以APP被唤醒有2种原因：用户操作了按键，超时。被唤醒的APP在内核态继续运行，即继续执行驱动代码，把“状态”返回给APP(的用户空间)。
> - APP得到poll/select函数的返回结果后，如果确认是有数据的，则再调用read函数，这会导致驱动中的read函数被调用，这时驱动程序中含有数据，会直接返回数据。
>
> **异步通知 方式**（相当于应用程序的 异步通知方式获取）：
>
> - 异步通知的实现原理是：内核给APP发信号。信号有很多种，这里发的是SIGIO。
> - 驱动程序中构造、注册一个file_operations结构体，里面提供有对应的open,read,fasync函数。
> - APP调用open时，导致驱动中对应的open函数被调用，在里面配置GPIO为输入引脚；并且注册GPIO的中断处理函数。
> - APP给信号SIGIO注册自己的处理函数：my_signal_fun。
> - APP调用fcntl函数，把驱动程序的flag改为FASYNC，这会导致驱动程序的fasync函数被调用，它只是简单记录进程PID。
> - 当用户按下按键时，GPIO中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，然后给进程PID发送SIGIO信号。
> - APP收到信号后会被打断，先执行信号处理函数：在信号处理函数中可以去调用read函数读取按键值。信号处理函数返回后，APP会继续执行原先被打断的代码。
>
> 应用程序注册信号回调函数的例子见：`【Linux 应用开发】\1-文件io读写的基本四种机制\例程-来自百问网\05_input_read_fasync.c`。
>
> 关于 信号（signal）详解可见 [（真正全）Linux进程和线程的基本编程、通讯和例程【杂记】_Real-Staok的博客-CSDN博客](https://blog.csdn.net/Staokgo/article/details/124169573) 里的 `信号（Signal）`一节。

> **在 shell 中给进程发信号**：
>
> 假定应用程序叫 signal。
>
> ```shell
> ./signal &                    // 后台运行
> ps  -A | grep signal          // 查看进程ID，假设是 9527
> kill  -SIGIO  9527            // 给这个进程发名为 SIGIO 的信号
> ```

## 例子

### 查询方式-非阻塞

本节的源码路径：`查询方式-非阻塞\`。

> 我们的目的写出一个容易扩展到各种芯片、各种板子的按键驱动程序，所以驱动程序分为上下两层：
>
> ① button_drv.c分配/设置/注册file_operations结构体
>
> 起承上启下的作用，向上提供button_open,button_read供APP调用。
>
> 而这2个函数又会调用底层硬件提供的p_button_opr中的init、read函数操作硬件。
>
> ② board_xxx.c分配/设置/注册button_operations结构体
>
> 这个结构体是我们自己抽象出来的，里面定义单板xxx的按键操作函数。
>
> 这样的结构易于扩展，对于不同的单板，只需要替换board_xxx.c提供自己的button_operations结构体即可。

这里的程序结构与 `【Linux 驱动开发】\基本字符设备驱动程序-输出\进化1_外设操作和驱动程序分离` 和 `【Linux 驱动开发】\基本字符设备驱动程序-输出\进化2_支持多种板子` 一致，都是驱动程序单独出来，外设资源和外设操作 都放在另一个文件里面，外设操作（如初始化、读、写等）的 函数API 都打包放进 一个结构体 struct button_operations，然后 驱动程序 调用这个结构体里面的操作函数来操作硬件即可。

两个文件分别编译为两个模块，先加载驱动程序的模块，再才能加载 外设操作程序的模块。外设操作程序的模块在被加载的时候 才会调用 创建设备 （device_create），该模块卸载时候 再删除设备 （device_destroy）。

应用程序 open 时候 不传入 NOBLOCK 标志（因此驱动程序写的时候应该保证 不要有任何阻塞的语句），应用程序 read 的时候，驱动程序直接返回结果。

模块装载完毕之后，进行测试 01_button_drv_template：

```c
ls /dev/100ask_button* -l            // 查看设备节点
    返回：
    crw-------    1 root     root      236,   0 Jan 18 08:57 /dev/100ask_button0
    crw-------    1 root     root      236,   1 Jan 18 08:57 /dev/100ask_button1

./button_test /dev/100ask_button0    // 读按键
    返回：
    [450.886180] /home/book/source/04_button_drv/01_button_drv_template/board_xxx.c board_xxx_button_init_gpio 28, init gpio for button 0
    [450.910915] /home/book/source/04_button_drv/01_button_drv_template/board_xxx.c board_xxx_button_read_gpio 33, read gpio for button 0
    get button : 1                  // 得到数据
```

参考 100ask 的 04_button_drv。

### GPIO、Pinctrl 子系统的使用

本节的源码路径：`gpio_and_pinctrl\`。

教程 可看 `100ask对gpio和pinctrl子系统简明介绍.docx` 或 视频 [Pinctrl子系统重要概念-【第5篇】嵌入式Linux驱动开发基础知识_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV14f4y1Q7ti?p=32) 以及这个视频后面的几个视频连着看。

例子 `【Linux 驱动开发】\基本字符设备驱动程序-输入\gpio_and_pinctrl`，引自 100ask 05_gpio_and_pinctrl。

（后面的几段话是理解之后的描述，没学应该先去看教程）

后面的例子使用到 GPIO、Pinctrl 子系统。GPIO、Pinctrl 子系统 即 按照一定规则编写设备树的某些节点的属性和值，然后内核提供一些专用的 API 在驱动程序中来读取这些节点的属性，进而来方便的设置 IO 的 方向、值 等等。Pinctrl 用于引脚配置（配置为 GPIO 还是 复用为 I2C 等其它外设的引脚），GPIO 子系统就用于标记出要使用哪些 IO 、配置引脚方向 和 把引脚配置为输入、输出等简单的功能（供驱动程序获取），注意：一个是相当于设置 IO 的 IOMUX，另一个是 使用 IO，要用到某一个 IO 时候这两处都要在设备树中设置一下。当驱动 drive 与 设备树 中的 设备节点 匹配之后，会自动根据里面的值去配置 IO，包括 default 状态和 sleep 状态，是内核自动完成的。

实现的效果就是：修改设备树，驱动里面调用 gpiod_xxx() 等相关的 API 来获取该 GPIO 并控制其 方向、值 等等，就这样。

> 要操作GPIO引脚，先把所用引脚配置为GPIO功能，这通过Pinctrl子系统来实现。
>
> 然后就可以根据设置引脚方向(输入还是输出)、读值──获得电平状态，写值──输出高低电平。
>
> 以前我们通过寄存器来操作GPIO引脚，即使LED驱动程序，对于不同的板子它的代码也完全不同。
>
> 当BSP工程师实现了GPIO子系统后，我们就可以：
>
> a. 在设备树里指定GPIO引脚
>
> b. 在驱动代码中：
>
> 使用GPIO子系统的标准函数获得GPIO、设置GPIO方向、读取/设置GPIO值。
>
> 这样的驱动代码，将是单板无关的。

对于使用来讲：对于 Pinctrl 子系统，是在 设备树中相应的 子节点下 要先有 pinctrl 的子节点，在里面写好各个 IO 配置为某个功能（①这个一般芯片厂家会提供，看看 公板/评估板 的 BSP 里面的 设备树，这个里面的 pinctrl 子节点 是 BSP工程师写好提供的，②会有工具软件来生成（如 imx 的 `Pins_Tool_for_i.MX...`工具），主要用于用户自己用到一些 IO，③如果没有生成工具就自己参考着来了，参考提供的文档或设备树源码），然后在自己的板子的设备树中去定义自己这个设备的节点（如果是用户自定IO，即 设备树里面没有要用的 pinctrl 的子节点，那么就按照前面 的方法来自己加上），在里面调用前面的 pinctrl 的子节点来设置板子上的 IO 功能，即设置 `pinctrl-name = "default", "sleep", ...; pinctrl-0 = <&...>;` 等这类属性。对于 GPIO 子系统，即在自己板子的设备树的该节点（自己这个设备的节点） 里 继续写 `xxx_gpios = <&... ... GPIO_ACTIVE_HIGH/LOW>;`等这种属性，驱动在与设备匹配（通过 compatible 属性等）之后 自动解析这些设备树节点和属性 并据此 配置指定的 IO，然后驱动可以调用 gpiod_xxx() 等相关的 API 来控制 IO 的 方向、值 等等。

一个设备树中方使用 GPIO、Pinctrl 的例子：

<img src="assets/设备树中方使用GPIO、Pinctrl的例子.png" alt="设备树中方使用GPIO、Pinctrl的例子" style="zoom:150%;" />

对上图说明：其中在 自己板子的设备树的 最外层 定义一个 IO 的节点（左边），`pinctrl-0` 引用 生成的 IO MUX 配置信息节点（右上），然后在左边可以直接继续写 `xxx_gpios = <&... ... GPIO_ACTIVE_HIGH/LOW>;` 或者再定义一个子节点然后在里面写。然后就可以在驱动程序中的 probe 函数中 获取 该 IO、配置方向 和 读写了。还要确定该引脚没有其它节点使用，直接搜索  `xxx_gpios = <&... ... GPIO_ACTIVE_HIGH/LOW>;` 的 < > 里面的内容找到其它用到 该 GPIO 的节点，然后可以在其中添加 `status = "disabled";` 即可将其禁用。注意这个例子是 imx6ull 的，不同 SoC 设备树的写法会有变化，多变通。

**引入 这两个子系统后，对于板子的区分 就依靠 设备树，驱动程序里面可以根据设备树里面指定的资源来编写 外设操作相关的程序，如果驱动程序编写的好，那么更换板子的时候驱动程序几乎不用更改，只修改设备树，那么这就是做的很漂亮、很优雅的活儿。**

参考 100ask 的 05_gpio_and_pinctrl。

### 中断方式-阻塞

现在新出的 ARM SoC 都使用 中断控制器 (Generic Interrupt Controller，GIC) 来管理所有外设的中断信号，当有一个或一些外设向 CPU 发出中断信号时 GIC根据其优先级选出一路中断信号 送达 CPU，然后 CPU 跳转到 异常向量表中的 中断处理函数（这些都是硬件完成的），然后进行现场保护、跳转到处理函数，从中断中退出后 进行现场恢复（这些都是软件完成的）。关于 ARM SoC 处理器架构、启动文件 和 GIC 结构的更多 可参考 [(主线剧情01-ARM-IMX6ULL基础学习记录_Real-Staok的博客-CSDN博客](https://blog.csdn.net/Staokgo/article/details/123430589)，[主线剧情-番外01-ARM系列快速鸟瞰_Real-Staok的博客-CSDN博客](https://blog.csdn.net/Staokgo/article/details/123798984)，看一看会了解的更加系统。

> GIC v3/v4用于 ARMv8 架构，即64位ARM芯片。
>
> 而GIC v2用于ARMv7和其他更低的架构。
>
> **注意**：如果想入理解ARM处理器架构，应该从裸机开始学习。**注意**：如果为了加快学习速度，建议先不看裸机。

**对硬件中断的处理的原则**

> 对硬件中断的处理 有 原则：不能嵌套，越快越好。
>
> **不能嵌套**：为了防止中断嵌套时候栈空间猛增等原因，也是为了简单化中断的处理，在Linux系统上中断无法嵌套：即当前中断A没处理完之前，不会响应另一个中断B(即使它的优先级更高)。
>
> **越快越好**：在中断的处理过程中，该CPU是不能进行进程调度的，所以中断的处理要越快越好，尽早让其他中断能被处理──进程调度靠定时器中断来实现。在单芯片系统中，假设中断处理很慢，那应用程序在这段时间内就无法执行：系统显得很迟顿。在SMP系统中，假设中断处理很慢，那么正在处理这个中断的CPU上的其他线程也无法执行。

**Linux 中断系统的重要数据结构**

[Linux中断系统的重要数据结构——【第5篇】嵌入式Linux驱动开发基础知识_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV14f4y1Q7ti?p=40)，或详看 `100ask对 Linux中断系统中的重要数据结构简明介绍.docx`。看一下有助于对中断过程中内核处理的逻辑和过程的了解。

Linux 内核的中断处理机制，源码详细分析：[Linux中断管理 (1)Linux中断管理机制 - ArnoldLu - 博客园 (cnblogs.com)](https://www.cnblogs.com/arnoldlu/p/8659981.html)。

#### 基本设置设备树、申请中断

**在设备树中定义中断**

定义 interrupt-controller 节点一般是 BSP 的设备树 写好的，在自己的板子的设备树中定义要用那个 io 作为 irq，则在自己设备节点中使用 `interrupt-parent = <&哪一个外设>;` 引用即可，然后用 `interrupt = <信号脚 RISING/FALLING/BOTH>;` 声明这个外设的具体哪个信号线和是什么电平触发。

```
// 设备树定义形式
interrupt-parent = <&哪一个外设>;           /* 指定哪一个外设 */
interrupt = <信号脚 RISING/FALLING/BOTH>;   /* 指定这个外设的哪一个信号脚（硬件上的） */

// 一个实例
// 比如 GPIO1 的 引脚 5，它表示要使用 gpio1 里的第 5号中断，hwirq 就是 5
interrupt-parent = <&gpio1>;
interrupts = <5 IRQ_TYPE_EDGE_RISING>;

// 触发电平类型可选：include/linux/irq.h
	IRQ_TYPE_EDGE_RISING	= 0x00000001
	IRQ_TYPE_EDGE_FALLING	= 0x00000002
	IRQ_TYPE_EDGE_BOTH	= (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING)
	IRQ_TYPE_LEVEL_HIGH	= 0x00000004
	IRQ_TYPE_LEVEL_LOW	= 0x00000008
```

> 引自 [设备树中的中断节点以及相关函数-28_杨斌并的博客-CSDN博客](https://blog.csdn.net/yangbinbingA/article/details/117919566)。
>
> ```
> 比如，对于GPI0来说，GPI0的节点也可以作为中断控制器，在 imxbull.dtsi 文件中 GPI01的节点内容如下所示：
> 这是 定义 interrupt-controller，是 BSP 中写好的
> gpio1: gpio@e209ceee {
>        compatible = "fsl,imx6ul-gpio","fs1,imx35-gpio";
>        reg = <ex0209ce0e ex4000>;
>        interrupts = <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>,
>                     <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>;
>        gpio-controller;
>        #gpio-cells = <2>;
>        interrupt-controller;
>        #interrupt-cells =<2>;
> };
> 
> 在我们自己的设备树里面描述一个外设的中断节点，
> key {
>         #address-cells = <1>;
>         #size-cells =<1>;
>         compatible = "key";                     // 用于匹配 driver
>         pinctrl-names = "default";              // pinctrl 子系统
>         pinctrl-0 =<&pinctrl_key>;              // 把管脚设置为 gpio 功能（而不是用于其它外设的引脚）
>         key-gpio = <&gpio1 18 GPIO_ACTIVE_LOW>; // gpio 子系统
>         
>         // 使用 interrupt-parent 和 interrupts 属性来描述中断
>         interrupt-parent = <&gpio1>;            // 指示用到的 interrupt 控制器，设置的是中断源
>         interrupts = <18 IRQ_TYPE_EDGE_BOTH>;   // 指示用到的 interrupt 控制器下面的哪一个 信号脚 和 触发电平
>         
>         status ="okay"; // 表示启用，写 disabled 表示不用/禁用
> }
> ```
>
> 新写法：一个 “interrupts-extended” 属性就可以既指定 “interrupt-parent”，也指定 “interrupts”，比如：
>
> ```
> interrupts-extended = <&intc1 5 1>, <&intc2 1 0>; // 这是定义了两个 IO 的中断
> ```

内核解析设备树后，将该设备节点 转化为 platform_device，并通过相关函数将 硬件中断号 hwirq 映射为（虚拟）中断号 irq，并保存在 platform_device 结构体里面，使用 request_irq 注册 中断处理函数 的时候 就用到这个 中断号 irq。

**得到中断号 irq**

1. 一个节点能被转换为 platform_device，如果它的设备树里指定了中断属性，那么可以使用 platform_device 获得“中断资源”，可以使用下列函数获得 IORESOURCE_IRQ 资源，即中断号：`struct resource *platform_get_resource(struct platform_device *dev, unsigned int type, unsigned int num);`。
2. 对于I2C设备、SPI设备：在 driver 与 device 匹配之后，调用 内核的 i2c/spi 相关的函数 xxx_probe 来将 i2c/spi 设备 platform_device 转化为 i2c_client 和 spi_device，并且使用 of_irq_get() 取出中断号 irq 赋值给 结构体里面的 irq 成员。
   - 一个I2C设备会被转换为一个i2c_client结构体，中断号会保存在i2c_client的irq成员里。
   - 一个SPI设备会被转换为一个spi_device结构体，中断号会保存在spi_device的irq成员里。
3. 如果你的设备节点既不能转换为 platform_device，它也不是I2C设备，不是SPI设备，那么在驱动程序中可以自行调用 of_irq_get 函数去解析设备树，得到中断号。
4. 通过设备节点 struct device_node 返回中断号 irq 的函数 `unsigned int irq of_parse_and_map(struct device_node *dev,int index)`。
5. 通过设备节点 struct device_node 返回 gpio 号 使用 `of_get_gpio_flags` 或 `of_get_named_gpio_flags`，再用 `gpio_to_irq` 通过 gpio 号得到 irq 号。第一个 API 得到的 flag 可以直接传入 request_irq。另外 可以使用 `gpio_to_desc` 通过 gpio 号来获得 struct gpio_desc 进而使用 `gpiod_xxx()` 来 设置方向、读写 等等。
   - 参考程序：100ask 的 `01_all_series_quickstart\05_嵌入式Linux驱动开发基础知识\source\06_gpio_irq\01_simple\gpio_key_drv.c`。
   - 参考：[Linux驱动编程操作GPIO的简要说明_平仄散人的博客-CSDN博客_of_get_gpio_flags](https://blog.csdn.net/qq_30624591/article/details/87834629)，这个里面 获取 gpio 的相关 API 使用的是 通过 名字字符串 来找到，我觉得不如 上面 100ask 例子里面的，都是通过 设备节点来寻找 而不是通过字符串。

**申请中断**

参考 100ask、[设备树中的中断节点以及相关函数-28_杨斌并的博客-CSDN博客](https://blog.csdn.net/yangbinbingA/article/details/117919566)，[request_irq() | 注册中断服务_专注android开发的博客-CSDN博客_request_irq](https://blog.csdn.net/wealoong/article/details/7566546)。

```c
#include <linux/interrupt.h>
int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev);

    irq：要申请中断的中断号 irq
        
    handler：中断处理函数，当中断发生以后就会执行此中断处理函数
        比如 static irqreturn_t gpio_key_isr(int irq, void *dev_id)
            第一个参数 irq：中断处理函数相应的中断号
            第二个参数 dev_id：与 request_irq 函数的 dev 参数一致，传入参数用
            返回值：枚举类型，可以是 IRQ_NONE、IRQ_HANDLED、IRQ_WAKE_THREAD，一般是 IRQ_HANDLED
        
    flags：中断标志，可填如下
        #define IRQF_DISABLED 			0x00000020 /*中断禁止*/
        #define IRQF_SAMPLE_RANDOM  	0x00000040 /*供系统产生随机数使用*/
        #define IRQF_SHARED      		0x00000080 /*在设备之间可共享*/
        #define IRQF_PROBE_SHARED   	0x00000100/*探测共享中断*/
        #define IRQF_TIMER       		0x00000200/*专用于时钟中断*/
        #define IRQF_PERCPU      		0x00000400/*每CPU周期执行中断*/
        #define IRQF_NOBALANCING 		0x00000800/*复位中断*/
        #define IRQF_IRQPOLL     		0x00001000/*共享中断中根据注册时间判断*/
        #define IRQF_ONESHOT     		0x00002000/*硬件中断处理完后触发*/
        #define IRQF_TRIGGER_NONE   	0x00000000/*无触发中断*/
        
        /* 这几个 RISING/FALLING/HIGH/LOW 与 设备树里面的定义一致，因此 of_get_gpio_flags() 得到的 flag 可以直接填入此处的 flags */
        #define IRQF_TRIGGER_RISING 	0x00000001/*指定中断触发类型：上升沿有效*/ 
        #define IRQF_TRIGGER_FALLING 	0x00000002/*中断触发类型：下降沿有效*/
        #define IRQF_TRIGGER_HIGH   	0x00000004/*指定中断触发类型：高电平有效*/
        #define IRQF_TRIGGER_LOW 		0x00000008/*指定中断触发类型：低电平有效*/
        
        #define IRQF_TRIGGER_MASK   (IRQF_TRIGGER_HIGH | IRQF_TRIGGER_LOW | \
        IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)
        #define IRQF_TRIGGER_PROBE  	0x00000010/*触发式检测中断*/
        
    name：设置中断名称，通常是设备驱动程序的名称  在 cat/proc/interrupts 中可以看到此名称
    
    dev：给中断函数传入参数。或者 在中断共享时会用到，一般设置为这个设备的设备结构体或者NULL
    
    返回值：成功返回 0
        
        
中断使用完成以后就要通过 free_irq函数释放掉相应的中断。如果中断不是共享的，那么free_irq会删除中断处理函数并且禁止中断
void free _irq(unsigned int irq,void*dev);
    irq:要释放的中断。
    dev:如果中断设置为共享(IRQF_SHARED)的话，此参数用来区分具体的中断。共享中断只有在释放最后中断处理函数的时候才会被禁止掉。
    返回值:无。
```

> 中断成功后可以通过下面的指令查看 `cat /proc/irq/申请的中断号/spurious`。

本节的程序例子见文件夹 `【Linux 驱动开发】\基本字符设备驱动程序-输入\中断方式-阻塞\simple`，引自 100ask 的 01_simple。设备树的修改方法见同目录下的 `本节设备树的修改.docx` 文件。

下面三种驱动编写 休眠-中断、Poll 方式 和 异步通知方式 都是基于 中断 的。

#### 休眠-中断

> **当应用程序必须等待某个事件发生**，比如必须等待按键被按下时，**可以使用“休眠-唤醒”机制**：
>
> ① APP调用read等函数试图读取数据，比如读取按键；
>
> ② APP进入内核态，也就是调用驱动中的对应函数，发现有数据则复制到用户空间并马上返回；
>
> ③ 如果APP在内核态，也就是在驱动程序中发现没有数据，则APP休眠；所谓休眠就是把自己的状态改为非RUNNING，这样内核的调度器就不会让它运行。
>
> ④ 当有数据时，比如当按下按键时，驱动程序的中断服务程序被调用，它会记录数据、唤醒APP；唤醒就是把程序的状态改为RUNNING，这样内核的调度器有合适的时间就会让它运行。
>
> ⑤ APP继续运行它的内核态代码，也就是驱动程序中的函数，复制数据到用户空间并马上返回。
>
> **在中断处理函数中，不能休眠**，也就不能调用会导致休眠的函数。

> **休眠函数**
>
> 参考内核源码：include\linux\wait.h。
>
> | 函数                                                     | 说明                                                         |
> | -------------------------------------------------------- | ------------------------------------------------------------ |
> | wait_event_interruptible(wq, condition)                  | 休眠，直到condition为真；  休眠期间是可被打断的，可以被信号打断 |
> | wait_event(wq, condition)                                | 休眠，直到condition为真；  退出的唯一条件是condition为真，信号也不能打断 |
> | wait_event_interruptible_timeout(wq, condition, timeout) | 休眠，直到condition为真或超时；  休眠期间是可被打断的，可以被信号打断 |
> | wait_event_timeout(wq, condition, timeout)               | 休眠，直到condition为真；  退出的唯一条件是condition为真，信号也不好使 |
>
> 比较重要的参数就是：
>
> ① wq：waitqueue，等待队列
>
> 休眠时除了把程序状态改为非RUNNING之外，还要把进程/进程放入wq中，以后中断服务程序要从wq中把它取出来唤醒。
>
> ② condition
>
> 这可以是一个变量，也可以是任何表达式。表示“一直等待，直到condition为真”。
>
> **唤醒函数**
>
> 参考内核源码：include\linux\wait.h。
>
> | 函数                            | 说明                                                         |
>| ------------------------------- | ------------------------------------------------------------ |
> | wake_up_interruptible(x)        | 唤醒x队列中状态为“TASK_INTERRUPTIBLE”的线程，只唤醒其中的一个线程 |
> | wake_up_interruptible_nr(x, nr) | 唤醒x队列中状态为“TASK_INTERRUPTIBLE”的线程，只唤醒其中的nr个线程 |
> | wake_up_interruptible_all(x)    | 唤醒x队列中状态为“TASK_INTERRUPTIBLE”的线程，唤醒其中的所有线程 |
> | wake_up(x)                      | 唤醒x队列中状态为“TASK_INTERRUPTIBLE”或“TASK_UNINTERRUPTIBLE”的线程，只唤醒其中的一个线程 |
> | wake_up_nr(x, nr)               | 唤醒x队列中状态为“TASK_INTERRUPTIBLE”或“TASK_UNINTERRUPTIBLE”的线程，只唤醒其中nr个线程 |
> | wake_up_all(x)                  | 唤醒x队列中状态为“TASK_INTERRUPTIBLE”或“TASK_UNINTERRUPTIBLE”的线程，唤醒其中的所有线程 |

做法就是：

1. 初始化 wq 队列 `static DECLARE_WAIT_QUEUE_HEAD(wq);`。
2. 在驱动的 read 函数中，调用  `wait_event_interruptible(wq, event);`，它会判断 event 是否为 FALSE，如果为 FASLE 则休眠。
3. 在中断服务程序里，读取摁键的值，若被摁下，则设置 event 为 TRUE，并调用 `wake_up_interruptible(wq);` 唤醒线程。

本节例子（设备树同 simple 文件夹内的） `基本字符设备驱动程序-输入\中断方式-阻塞\休眠-中断方式\read_key_irq_wait` 和 `基本字符设备驱动程序-输入\中断方式-阻塞\休眠-中断方式\read_key_irq_wqit-circle_buffer`。第二个例子是使用环形队列来 存储和取出 按键的值。本例子 需要修改设备树，按需来。例子引自 100ask 的 02_read_key_irq 和 03_read_key_irq_circle_buffer 。

> 环形缓冲程序：
>
> ```c
> /* 环形缓冲区 */
> #define BUF_LEN 128
> static int g_keys[BUF_LEN];
> static int r, w;
> 
> #define NEXT_POS(x) ((x + 1) % BUF_LEN) /* 0~127 循环 */
> 
> static int is_key_buf_empty(void)
> {
> 	return (r == w);
> }
> 
> static int is_key_buf_full(void)
> {
> 	return (r == NEXT_POS(w)); /* 下一个写的位置 w 等于读的位置 r 则认为满 */
> }
> 
> static int put_key(int key)
> {
> 	if (!is_key_buf_full()) /* 如果满则不能存 */
> 	{
> 		g_keys[w] = key; /* 存储输入值 */
> 		w = NEXT_POS(w); /* w 索引值 +1 */
>          return 0;
> 	}
>     return -1;
> }
> 
> static int get_key(void)
> {
> 	int key = 0;
> 	if (!is_key_buf_empty()) /* 如果空则不能读 */
> 	{
> 		key = g_keys[r]; /* 取出 */
> 		r = NEXT_POS(r); /* r 索引值 +1 */
> 	}
> 	return key;
> }
> ```

#### Poll方式 《学到此先告一段落，毕设差不多之后再接着看

**TODO 继续 100ask 手册的 《19.2  POLL机制》**

#### 异步通知方式



### 中断中要处理复杂任务的策略

这部分内容参考 《嵌入式Linux应用开发完全手册V4.0_韦东山全系列视频文档-IMX6ULL开发板》的 `18.2.4`、`18.2.5` 和 `19.6  中断下半部tasklet`、`19.7  工作队列` 等部分。**TODO 看完之后整理过来**

> Linux系统把中断的意义扩展了，对于按键中断等硬件产生的中断，称之为“**硬件中断**”(hard irq)。每个硬件中断都有对应的处理函数，比如按键中断、网卡中断的处理函数肯定不一样。
>
> 当发生A中断时，对应的irq_function_A函数被调用。硬件导致该函数被调用。
>
> 还可以人为地制造中断：**软件中断**(soft irq)
>
> a. 软件中断何时生产？由软件决定，对于X号软件中断，只需要把它的flag设置为1就表示发生了该中断。
>
> b. 软件中断何时处理？
>
> 软中断的 flag 标志位 是在每一次 硬件中断 里面最后检查一下，在处理完硬件中断后，再去处理软件中断。Linux系统中，各种硬件中断频繁发生，至少定时器中断每 10ms 发生一次。
>
> 怎么设置软件中断？最核心的函数是 raise_softirq（这个函数由内核调用），这个函数简单地理解就是设置softirq_veq[nr]的标记位。
>
> 设置软件中断的处理函数：`extern void open_softirq(int nr, void (*action) (struct soft_action*));`。
>
> - [软中断（softirq）机制_tiangwan2011的博客-CSDN博客_raise_softirq](https://blog.csdn.net/tiangwan2011/article/details/7254806)。
>
> 中断下半部 tasklet 就是使用软件中断实现的。

#### ①拆分为上半部、下半部

> 中断处理的过程中其它中断和进程都无法被处理，中断中要处理的事情实在太多，因此将处理任务拆分为上、下半两个部分，上本部分在 中断处理函数 handler 只处理紧急的事务，然后退出中断，让系统得以正常运行，然后启动下半部分用来处理那些不紧急的事。
>
> ![中断上下半部分图说明](assets/中断上下半部分图说明.png)
>

中断下半部的实现有很多种方法，讲 2 种主要的：tasklet(小任务)、work queue(工作队列)。

**下半部要做的事情耗时不是太长：tasklet**

> 当下半部比较耗时但是能忍受，并且它的处理比较简单时，可以用tasklet来处理下半部。**tasklet 是使用软件中断来实现**。

在中断上半部中是原子操作（系统自动在处理前和处理后失能中断和使能中断），不能被其它任何中断打断（其它进程不会执行，系统也不能调度（调度是在另一个定时器中断里面进行的）），中断下半部不是原子操作，执行中可以被其它中断打断（可能会被打断多次）。

两种情况：

- 对于同一个中断，当执行下半部的时候（下半部还没执行完毕的期间内），如果又发生了一次或多次同一个这个中断，那么中断发生几次，上半部就执行几次（比如 n 次），但是下半部只执行 1 次（不会重复执行），直到下半部完全执行完毕，因此要注意这个 n : 1 的关系，中断一次就必须要做一次的事情（比如重要的指示信号）就必须放到上半部，其它的不紧急的事务就放到下半部再做处理。
- 对于 中断A 在执行 下半部的时候 B 中断发生，这种情况，A 和 B 的上半部都各执行了一次，但是 下半部依旧是 只执行一次（A 触发的那一次），在这一次下半部里面 会处理所有的软件中断，因此如果 A 和 B 的下半部都是用软件中断来做的，即都是用 tasklet，那么这个情况和过程中 A 和 B 的下半部也相当于各执行了一次（具体分析看 源码里的 preempt_count 计数机制，100ask 手册的 `18.2.5  下半部要做的事情耗时不是太长：tasklet` 一节）。



**下半部要做的事情太多并且很复杂：work queue**

> 假设下半部要执行1、2分钟，在这1、2分钟里APP都是无法响应的。
>
> 所以，如果中断要做的事情实在太耗时，那就不能用软件中断来做，而应该用内核线程来做。内核线程和APP都一样竞争执行，APP有机会执行，系统不会卡顿。

**就是说下半部实在太长了，就使用内核线程来执行下半部**。做法就是在中断的上半部中 将一个执行下半部任务的函数放入 work 结构体里面，然后 将这个 work 放入 work queue 队列里面，后续 kworker 内核线程 会依次执行 work queue 队列里面 work 里面的函数，也就是下半部。缺点就是 一个 kworker 内核线程只运行在一个 CPU 中，放入它的 work queue 队列里面的函数也都在这一个 CPU 中运行，无法利用多核来分担负载，下面的 threaded irq（线程化中断）可以解决该问题。

**TODO**：是不是对于内核来说 线程、进程一样，或者说 内核线程与进程对于内核来说是一样的。

**中断的上、下半部 更多参考**

- [中断的上下半部_天糊土的博客-CSDN博客_中断上下半部](https://blog.csdn.net/oqqHuTu12345678/article/details/78860065)。
- [中断处理“下半部”机制_Arrow的博客-CSDN博客_中断下半部](https://blog.csdn.net/myarrow/article/details/9287169)。



- [Linux的中断处理机制 [一\] - 数据结构(1) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/83709066)。
- [Linux的中断处理机制 [二\] - 数据结构(2) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/85353687)。
- [Linux的中断处理机制 [三\] - hardirq - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/85454778)。
- [Linux的中断处理机制 [四\] - softirq(1) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/80371745)。
- [Linux的中断处理机制 [五\] - softirq(2) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/80680484)。
- [Linux中的中断处理机制 [六\] - 从tasklet到中断线程化 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/89913872)。

#### ②用内核线程处理中断

> 以前用work来线程化地处理中断，一个worker线程只能由一个CPU执行，多个中断的work都由同一个worker线程来处理，在单CPU系统中也只能忍着了。但是在SMP系统中，明明有那么多CPU空着，你偏偏让多个中断挤在这个CPU上？（也就是说 work queue 处理的线程都在一个 CPU 上面，对于多 CPU 的 SoC 是浪费资源、CPU 负载很不均衡）
>
> threaded irq 即让用户提供一个函数，系统会为这个函数创建一个内核线程。发生中断时，内核线程就会执行这个函数。
>
> 新技术 threaded irq，为每一个中断都创建一个内核线程；多个中断的内核线程可以分配到多个CPU上执行，这提高了效率。

threaded irq（线程化中断）可以 创建 不同的 内核线程（threaded irq 给一个中断单独创建一个内核线程，当中断发生时候 先执行 中断回调函数 来执行上半部，然后运行 threaded irq 前面创建的内核线程 来执行下半部） 运行于 不同的 CPU 核。

> 可以提供handler而不提供thread_fn，就退化为一般的request_irq函数。
>
> 可以不提供handler只提供thread_fn，完全由内核线程来处理中断。
>
> 也可以既提供handler也提供thread_fn，这就是中断上半部、下半部。
